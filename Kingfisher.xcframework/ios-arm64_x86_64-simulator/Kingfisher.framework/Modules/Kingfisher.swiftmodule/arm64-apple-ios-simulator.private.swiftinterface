// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-upcoming-feature StrictConcurrency -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name Kingfisher
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import AVKit
import Accelerate
import CarPlay
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import CryptoKit
import Foundation
import ImageIO
import MobileCoreServices
import Photos
import PhotosUI
import Swift
import SwiftUI
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol ImageModifier : Swift.Sendable {
  func modify(_ image: Kingfisher.KFCrossPlatformImage) -> Kingfisher.KFCrossPlatformImage
}
public struct AnyImageModifier : Kingfisher.ImageModifier {
  public init(modify: @escaping @Sendable (Kingfisher.KFCrossPlatformImage) throws -> Kingfisher.KFCrossPlatformImage)
  public func modify(_ image: Kingfisher.KFCrossPlatformImage) -> Kingfisher.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : Kingfisher.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: Kingfisher.KFCrossPlatformImage) -> Kingfisher.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : Kingfisher.ImageModifier {
  public init()
  public func modify(_ image: Kingfisher.KFCrossPlatformImage) -> Kingfisher.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : Kingfisher.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: Kingfisher.KFCrossPlatformImage) -> Kingfisher.KFCrossPlatformImage
}
public protocol CacheSerializer : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  func data(with image: Kingfisher.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func image(with data: Foundation.Data, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
  var originalDataUsed: Swift.Bool { get }
}
extension Kingfisher.CacheSerializer {
  public var originalDataUsed: Swift.Bool {
    get
  }
}
public struct DefaultCacheSerializer : Kingfisher.CacheSerializer {
  public static let `default`: Kingfisher.DefaultCacheSerializer
  public var compressionQuality: CoreFoundation.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public var originalDataUsed: Swift.Bool {
    get
  }
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(with image: Kingfisher.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func image(with data: Foundation.Data, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public protocol ImageDataProvider : Swift.Sendable {
  var cacheKey: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var contentURL: Foundation.URL? { get }
  #endif
}
extension Kingfisher.ImageDataProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentURL: Foundation.URL? {
    get
  }
  #endif
  public func convertToSource() -> Kingfisher.Source
}
public struct LocalFileImageDataProvider : Kingfisher.ImageDataProvider {
  public let fileURL: Foundation.URL
  #if compiler(>=5.3) && $NonescapableTypes
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil, loadingQueue: Kingfisher.ExecutionQueue = .dispatch(DispatchQueue.global(qos: .userInitiated)))
  #endif
  public var cacheKey: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
  public var data: Foundation.Data {
    get async throws
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentURL: Foundation.URL? {
    get
  }
  #endif
}
public struct Base64ImageDataProvider : Kingfisher.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(handler: (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
}
public struct RawImageDataProvider : Kingfisher.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
}
public protocol AnimatedImageViewDelegate : AnyObject {
  func animatedImageView(_ imageView: Kingfisher.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  func animatedImageViewDidFinishAnimating(_ imageView: Kingfisher.AnimatedImageView)
}
extension Kingfisher.AnimatedImageViewDelegate {
  public func animatedImageView(_ imageView: Kingfisher.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  public func animatedImageViewDidFinishAnimating(_ imageView: Kingfisher.AnimatedImageView)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedImageView : Kingfisher.KFCrossPlatformImageView {
  public enum RepeatCount : Swift.Equatable {
    case once
    case finite(count: Swift.UInt)
    case infinite
    public static func == (lhs: Kingfisher.AnimatedImageView.RepeatCount, rhs: Kingfisher.AnimatedImageView.RepeatCount) -> Swift.Bool
  }
  @_Concurrency.MainActor @preconcurrency public var autoPlayAnimatedImage: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var framePreloadCount: Swift.Int
  @_Concurrency.MainActor @preconcurrency public var needsPrescaling: Swift.Bool
  @available(*, deprecated, message: "    This property does not perform as declared and may lead to performance degradation.\n    It is currently obsolete and scheduled for removal in a future version.")
  @_Concurrency.MainActor @preconcurrency public var backgroundDecode: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var runLoopMode: Foundation.RunLoop.Mode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var repeatCount: Kingfisher.AnimatedImageView.RepeatCount {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any Kingfisher.AnimatedImageViewDelegate)?
  @_Concurrency.MainActor @preconcurrency public var animator: Kingfisher.AnimatedImageView.Animator? {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @objc override dynamic open var image: Kingfisher.KFCrossPlatformImage? {
    @objc get
    @objc set
  }
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isAnimating: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func startAnimating()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func stopAnimating()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func display(_ layer: QuartzCore.CALayer)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToSuperview()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(image: UIKit.UIImage?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 3.0, *)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
}
extension Kingfisher.AnimatedImageView {
  @_hasMissingDesignatedInitializers public class Animator : @unchecked Swift.Sendable {
    final public let maxFrameCount: Swift.Int
    #if compiler(>=5.3) && $NonescapableTypes
    public var currentFrameImage: Kingfisher.KFCrossPlatformImage? {
      get
    }
    #endif
    public var currentFrameDuration: Foundation.TimeInterval {
      get
    }
    public var currentFrameIndex: Swift.Int {
      get
    }
    public var isLastFrame: Swift.Bool {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public func frame(at index: Swift.Int) -> Kingfisher.KFCrossPlatformImage?
    #endif
    public func duration(at index: Swift.Int) -> Foundation.TimeInterval
    @objc deinit
  }
}
public enum StorageExpiration : Swift.Sendable {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending : Swift.Sendable {
  case none
  case cacheTime
  case expirationTime(_: Kingfisher.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
public protocol Placeholder {
  @_Concurrency.MainActor func add(to imageView: Kingfisher.KFCrossPlatformImageView)
  @_Concurrency.MainActor func remove(from imageView: Kingfisher.KFCrossPlatformImageView)
}
@_Concurrency.MainActor extension UIKit.UIImage : Kingfisher.Placeholder {
  @_Concurrency.MainActor public func add(to imageView: Kingfisher.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func remove(from imageView: Kingfisher.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func add(to base: any Kingfisher.KingfisherHasImageComponent)
  @_Concurrency.MainActor public func remove(from base: any Kingfisher.KingfisherHasImageComponent)
}
@_Concurrency.MainActor extension Kingfisher.Placeholder where Self : UIKit.UIView {
  @_Concurrency.MainActor public func add(to imageView: Kingfisher.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func remove(from imageView: Kingfisher.KFCrossPlatformImageView)
}
public enum DiskStorage {
  @_hasMissingDesignatedInitializers public class Backend<T> : @unchecked Swift.Sendable where T : Kingfisher.DataTransformable {
    public var config: Kingfisher.DiskStorage.Config {
      get
      set
    }
    final public let directoryURL: Foundation.URL
    convenience public init(config: Kingfisher.DiskStorage.Config) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public func store(value: T, forKey key: Swift.String, expiration: Kingfisher.StorageExpiration? = nil, writeOptions: Foundation.Data.WritingOptions = [], forcedExtension: Swift.String? = nil) throws
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public func value(forKey key: Swift.String, forcedExtension: Swift.String? = nil, extendingExpiration: Kingfisher.ExpirationExtending = .cacheTime) throws -> T?
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public func isCached(forKey key: Swift.String, forcedExtension: Swift.String? = nil) -> Swift.Bool
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public func isCached(forKey key: Swift.String, referenceDate: Foundation.Date, forcedExtension: Swift.String? = nil) -> Swift.Bool
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public func remove(forKey key: Swift.String, forcedExtension: Swift.String? = nil) throws
    #endif
    public func removeAll() throws
    #if compiler(>=5.3) && $NonescapableTypes
    public func cacheFileURL(forKey key: Swift.String, forcedExtension: Swift.String? = nil) -> Foundation.URL
    #endif
    public func removeExpiredValues() throws -> [Foundation.URL]
    public func removeSizeExceededValues() throws -> [Foundation.URL]
    public func totalSize() throws -> Swift.UInt
    @objc deinit
  }
}
extension Kingfisher.DiskStorage {
  public struct Config : @unchecked Swift.Sendable {
    public var sizeLimit: Swift.UInt
    public var expiration: Kingfisher.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public var autoExtAfterHashedFileName: Swift.Bool
    public var cachePathBlock: (@Sendable (_ directory: Foundation.URL, _ cacheName: Swift.String) -> Foundation.URL)!
    public let name: Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
    #endif
  }
}
public enum MemoryStorage {
  public class Backend<T> : @unchecked Swift.Sendable where T : Kingfisher.CacheCostCalculable {
    public var config: Kingfisher.MemoryStorage.Config {
      get
      set
    }
    public init(config: Kingfisher.MemoryStorage.Config)
    public func removeExpired()
    #if compiler(>=5.3) && $NonescapableTypes
    public func store(value: T, forKey key: Swift.String, expiration: Kingfisher.StorageExpiration? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public func value(forKey key: Swift.String, extendingExpiration: Kingfisher.ExpirationExtending = .cacheTime) -> T?
    #endif
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func remove(forKey key: Swift.String)
    public func removeAll()
    @objc deinit
  }
}
extension Kingfisher.MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: Kingfisher.StorageExpiration
    public var cleanInterval: Foundation.TimeInterval
    public var keepWhenEnteringBackground: Swift.Bool
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImage {
  @_hasMissingDesignatedInitializers public class Context<HoldingView> : @unchecked Swift.Sendable where HoldingView : Kingfisher.KFImageHoldingView {
    @objc deinit
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImage.Context : Swift.Hashable {
  public static func == (lhs: Kingfisher.KFImage.Context<HoldingView>, rhs: Kingfisher.KFImage.Context<HoldingView>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFAnimatedImage {
  public typealias Context = Kingfisher.KFImage.Context
}
extension AVFoundation.AVAssetImageGenerator : @unchecked @retroactive Swift.Sendable {
}
public struct AVAssetImageDataProvider : Kingfisher.ImageDataProvider {
  public enum AVAssetImageDataProviderError : Swift.Error {
    case userCancelled
    case invalidImage(_: CoreGraphics.CGImage?)
  }
  public let assetImageGenerator: AVFoundation.AVAssetImageGenerator
  public let time: CoreMedia.CMTime
  public var cacheKey: Swift.String {
    get
  }
  public init(assetImageGenerator: AVFoundation.AVAssetImageGenerator, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, seconds: Foundation.TimeInterval)
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
}
public class Delegate<Input, Output> : @unchecked Swift.Sendable {
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func delegate<T>(on target: T, block: ((T, Input) -> Output)?) where T : AnyObject
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func delegate<T>(on target: T, block: ((T, Input) async -> Output)?) where T : AnyObject
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func call(_ input: Input) -> Output?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func callAsFunction(_ input: Input) -> Output?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func callAsync(_ input: Input) async -> Output?
  #endif
  public var isSet: Swift.Bool {
    get
  }
  @objc deinit
}
extension Kingfisher.Delegate where Input == () {
  #if compiler(>=5.3) && $NonescapableTypes
  public func call() -> Output?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func callAsFunction() -> Output?
  #endif
}
extension Kingfisher.Delegate where Input == (), Output : Kingfisher.OptionalProtocol {
  public func call() -> Output
  public func callAsFunction() -> Output
}
extension Kingfisher.Delegate where Output : Kingfisher.OptionalProtocol {
  public func call(_ input: Input) -> Output
  public func callAsFunction(_ input: Input) -> Output
}
public protocol OptionalProtocol {
  static var _createNil: Self { get }
}
#if compiler(>=5.3) && $NonescapableTypes
extension Swift.Optional : Kingfisher.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
#endif
public enum ImageTransition : Swift.Sendable {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: (@_Concurrency.MainActor @Sendable (UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: (@Sendable (Swift.Bool) -> Swift.Void)?)
}
public struct LivePhotoSource : Swift.Sendable {
  public let resources: [Kingfisher.LivePhotoResource]
  public init(resources: [any Kingfisher.Resource])
  public init(urls: [Foundation.URL])
  public init(_ resources: [Kingfisher.LivePhotoResource])
}
public struct LivePhotoResource : Swift.Sendable {
  public enum FileType : Swift.Sendable, Swift.Equatable {
    case heic
    case mov
    case other(Swift.String)
    public static func == (a: Kingfisher.LivePhotoResource.FileType, b: Kingfisher.LivePhotoResource.FileType) -> Swift.Bool
  }
  public let dataSource: Kingfisher.Source
  public let referenceFileType: Kingfisher.LivePhotoResource.FileType
  #if compiler(>=5.3) && $NonescapableTypes
  public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil, fileType: Kingfisher.LivePhotoResource.FileType? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(resource: any Kingfisher.Resource, fileType: Kingfisher.LivePhotoResource.FileType? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(source: Kingfisher.Source, fileType: Kingfisher.LivePhotoResource.FileType? = nil)
  #endif
}
public struct ImageProgressive : Swift.Sendable {
  public enum UpdatingStrategy {
    case `default`
    case keepCurrent
    case replace(Kingfisher.KFCrossPlatformImage?)
  }
  @available(*, deprecated, renamed: "init()", message: "Getting a default `ImageProgressive` is deprecated due to its syntax semantic is not clear. Use `ImageProgressive.init` instead.")
  public static let `default`: Kingfisher.ImageProgressive
  public var isBlur: Swift.Bool
  public var isFastestScan: Swift.Bool
  public var scanInterval: Foundation.TimeInterval
  public let onImageUpdated: Kingfisher.Delegate<Kingfisher.KFCrossPlatformImage, Kingfisher.ImageProgressive.UpdatingStrategy>
  public init()
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
public enum ImageProcessItem : Swift.Sendable {
  case image(Kingfisher.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor : Swift.Sendable {
  var identifier: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
extension Kingfisher.ImageProcessor {
  public func append(another: any Kingfisher.ImageProcessor) -> any Kingfisher.ImageProcessor
}
public struct DefaultImageProcessor : Kingfisher.ImageProcessor {
  public static let `default`: Kingfisher.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct RectCorner : Swift.OptionSet, Swift.Sendable {
  public let rawValue: Swift.Int
  public static let topLeft: Kingfisher.RectCorner
  public static let topRight: Kingfisher.RectCorner
  public static let bottomLeft: Kingfisher.RectCorner
  public static let bottomRight: Kingfisher.RectCorner
  public static let all: Kingfisher.RectCorner
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = Kingfisher.RectCorner
  public typealias Element = Kingfisher.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreFoundation.CGFloat
  public let backgroundColor: Kingfisher.KFCrossPlatformColor?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: Kingfisher.KFCrossPlatformColor? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public enum Radius : Swift.Sendable {
  case widthFraction(CoreFoundation.CGFloat)
  case heightFraction(CoreFoundation.CGFloat)
  case point(CoreFoundation.CGFloat)
  public func compute(with size: CoreFoundation.CGSize) -> CoreFoundation.CGFloat
}
public struct RoundCornerImageProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let radius: Kingfisher.Radius
  public let roundingCorners: Kingfisher.RectCorner
  public let targetSize: CoreFoundation.CGSize?
  public let backgroundColor: Kingfisher.KFCrossPlatformColor?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(cornerRadius: CoreFoundation.CGFloat, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: Kingfisher.RectCorner = .all, backgroundColor: Kingfisher.KFCrossPlatformColor? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(radius: Kingfisher.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: Kingfisher.RectCorner = .all, backgroundColor: Kingfisher.KFCrossPlatformColor? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct Border : Swift.Sendable {
  public var color: Kingfisher.KFCrossPlatformColor
  public var lineWidth: CoreFoundation.CGFloat
  public var radius: Kingfisher.Radius
  public var roundingCorners: Kingfisher.RectCorner
  public init(color: Kingfisher.KFCrossPlatformColor = .black, lineWidth: CoreFoundation.CGFloat = 4, radius: Kingfisher.Radius = .point(0), roundingCorners: Kingfisher.RectCorner = .all)
}
public struct BorderImageProcessor : Kingfisher.ImageProcessor {
  public var identifier: Swift.String {
    get
  }
  public let border: Kingfisher.Border
  public init(border: Kingfisher.Border)
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public enum ContentMode : Swift.Sendable {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: Kingfisher.ContentMode, b: Kingfisher.ContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ResizingImageProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreFoundation.CGSize
  public let targetContentMode: Kingfisher.ContentMode
  public init(referenceSize: CoreFoundation.CGSize, mode: Kingfisher.ContentMode = .none)
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct BlurImageProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreFoundation.CGFloat
  public init(blurRadius: CoreFoundation.CGFloat)
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct OverlayImageProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: Kingfisher.KFCrossPlatformColor
  public let fraction: CoreFoundation.CGFloat
  public init(overlay: Kingfisher.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5)
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct TintImageProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let tint: Kingfisher.KFCrossPlatformColor
  public init(tint: Kingfisher.KFCrossPlatformColor)
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct ColorControlsProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreFoundation.CGFloat
  public let contrast: CoreFoundation.CGFloat
  public let saturation: CoreFoundation.CGFloat
  public let inputEV: CoreFoundation.CGFloat
  public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct BlackWhiteProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct CroppingImageProcessor : Kingfisher.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreFoundation.CGSize
  public let anchor: CoreFoundation.CGPoint
  public init(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5))
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct DownsamplingImageProcessor : Kingfisher.ImageProcessor {
  public let size: CoreFoundation.CGSize
  public let identifier: Swift.String
  public init(size: CoreFoundation.CGSize)
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
infix operator |> : AdditionPrecedence
public func |> (left: any Kingfisher.ImageProcessor, right: any Kingfisher.ImageProcessor) -> any Kingfisher.ImageProcessor
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  #if compiler(>=5.3) && $NonescapableTypes
  public var imageFrameCount: Swift.Int? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var imageSource: ImageIO.CGImageSource? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var frameSource: (any Kingfisher.ImageFrameSource)? {
    get
  }
  #endif
}
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public var normalized: Kingfisher.KFCrossPlatformImage {
    get
  }
}
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  #if compiler(>=5.3) && $NonescapableTypes
  public func pngRepresentation() -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func jpegRepresentation(compressionQuality: CoreFoundation.CGFloat) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func gifRepresentation() -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(format: Kingfisher.ImageFormat, compressionQuality: CoreFoundation.CGFloat = 1.0) -> Foundation.Data?
  #endif
}
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func animatedImage(data: Foundation.Data, options: Kingfisher.ImageCreatingOptions) -> Kingfisher.KFCrossPlatformImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func animatedImage(source: any Kingfisher.ImageFrameSource, options: Kingfisher.ImageCreatingOptions, baseImage: Kingfisher.KFCrossPlatformImage? = nil) -> Kingfisher.KFCrossPlatformImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func image(data: Foundation.Data, options: Kingfisher.ImageCreatingOptions) -> Kingfisher.KFCrossPlatformImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct LivePhotoLoadingInfoResult : Swift.Sendable {
  public let fileURLs: [Foundation.URL]
  public let cacheType: Kingfisher.CacheType
  public let source: Kingfisher.LivePhotoSource
  public let originalSource: Kingfisher.LivePhotoSource
  public let data: @Sendable () -> [Foundation.Data]
}
extension Kingfisher.KingfisherManager {
  #if compiler(>=5.3) && $NonescapableTypes
  public func retrieveLivePhoto(with source: Kingfisher.LivePhotoSource, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, referenceTaskIdentifierChecker: (() -> Swift.Bool)? = nil) async throws -> Kingfisher.LivePhotoLoadingInfoResult
  #endif
}
public protocol ImageDownloaderDelegate : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  func imageDownloader(_ downloader: Kingfisher.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didDownload data: Foundation.Data, with task: Kingfisher.SessionDataTask) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didDownload image: Kingfisher.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  #endif
  func isValidStatusCode(_ code: Swift.Int, for downloader: Kingfisher.ImageDownloader) -> Swift.Bool
  func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
}
extension Kingfisher.ImageDownloaderDelegate {
  #if compiler(>=5.3) && $NonescapableTypes
  public func imageDownloader(_ downloader: Kingfisher.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didDownload image: Kingfisher.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  #endif
  public func isValidStatusCode(_ code: Swift.Int, for downloader: Kingfisher.ImageDownloader) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didDownload data: Foundation.Data, with task: Kingfisher.SessionDataTask) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  #endif
  public func imageDownloader(_ downloader: Kingfisher.ImageDownloader, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
}
public protocol KingfisherImageSettable : Kingfisher.KingfisherCompatible {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func setImage(_ image: Kingfisher.KFCrossPlatformImage?, options: Kingfisher.KingfisherParsedOptionsInfo)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func getImage() -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public protocol KingfisherHasImageComponent : Kingfisher.KingfisherImageSettable {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor var image: Kingfisher.KFCrossPlatformImage? { get set }
  #endif
}
extension Kingfisher.KingfisherHasImageComponent {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func setImage(_ image: Kingfisher.KFCrossPlatformImage?, options: Kingfisher.KingfisherParsedOptionsInfo)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getImage() -> Kingfisher.KFCrossPlatformImage?
  #endif
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.UIAction : Kingfisher.KingfisherHasImageComponent {
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.UICommand : Kingfisher.KingfisherHasImageComponent {
}
extension UIKit.UIBarItem : Kingfisher.KingfisherHasImageComponent {
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : Kingfisher.KingfisherImageSettable {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any Kingfisher.Resource)?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any Kingfisher.Resource)?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any Kingfisher.ImageDataProvider)?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any Kingfisher.ImageDataProvider)?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : Kingfisher.KingfisherImageSettable {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public var taskIdentifier: Kingfisher.Source.Identifier.Value? {
    get
  }
  #endif
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor public protocol KFOptionSetter {
  @_Concurrency.MainActor var options: Kingfisher.KingfisherParsedOptionsInfo { get nonmutating set }
  @_Concurrency.MainActor var onFailureDelegate: Kingfisher.Delegate<Kingfisher.KingfisherError, Swift.Void> { get }
  @_Concurrency.MainActor var onSuccessDelegate: Kingfisher.Delegate<Kingfisher.RetrieveImageResult, Swift.Void> { get }
  @_Concurrency.MainActor var onProgressDelegate: Kingfisher.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> { get }
}
extension Kingfisher.KF.Builder : Kingfisher.KFOptionSetter {
}
extension Kingfisher.KFOptionSetter {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func onProgress(_ block: Kingfisher.DownloadProgressBlock?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func onSuccess(_ block: ((Kingfisher.RetrieveImageResult) -> Swift.Void)?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func onFailure(_ block: ((Kingfisher.KingfisherError) -> Swift.Void)?) -> Self
  #endif
}
extension Kingfisher.KFOptionSetter {
  @_Concurrency.MainActor public func targetCache(_ cache: Kingfisher.ImageCache) -> Self
  @_Concurrency.MainActor public func originalCache(_ cache: Kingfisher.ImageCache) -> Self
  @_Concurrency.MainActor public func downloader(_ downloader: Kingfisher.ImageDownloader) -> Self
  @_Concurrency.MainActor public func downloadPriority(_ priority: Swift.Float) -> Self
  @_Concurrency.MainActor public func forceRefresh(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func fromMemoryCacheOrRefresh(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func cacheMemoryOnly(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func waitForCache(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func onlyFromCache(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func backgroundDecode(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func callbackQueue(_ queue: Kingfisher.CallbackQueue) -> Self
  @_Concurrency.MainActor public func scaleFactor(_ factor: CoreFoundation.CGFloat) -> Self
  @_Concurrency.MainActor public func cacheOriginalImage(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func diskStoreWriteOptions(_ writingOptions: Foundation.Data.WritingOptions) -> Self
  @_Concurrency.MainActor public func loadDiskFileSynchronously(_ enabled: Swift.Bool = true) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func processingQueue(_ queue: Kingfisher.CallbackQueue?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func alternativeSources(_ sources: [Kingfisher.Source]?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func retry(_ strategy: (any Kingfisher.RetryStrategy)?) -> Self
  #endif
  @_Concurrency.MainActor public func retry(maxCount: Swift.Int, interval: Kingfisher.DelayRetryStrategy.Interval = .seconds(3)) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func lowDataModeSource(_ source: Kingfisher.Source?) -> Self
  #endif
  @_Concurrency.MainActor public func forceTransition(_ enabled: Swift.Bool = true) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func onFailureImage(_ image: Kingfisher.KFCrossPlatformImage?) -> Self
  #endif
}
extension Kingfisher.KFOptionSetter {
  @_Concurrency.MainActor public func requestModifier(_ modifier: any Kingfisher.AsyncImageDownloadRequestModifier) -> Self
  @_Concurrency.MainActor public func requestModifier(_ modifyBlock: @escaping @Sendable (inout Foundation.URLRequest) -> Swift.Void) -> Self
}
extension Kingfisher.KFOptionSetter {
  @_Concurrency.MainActor public func redirectHandler(_ handler: any Kingfisher.ImageDownloadRedirectHandler) -> Self
  @_Concurrency.MainActor public func redirectHandler(_ block: @escaping @Sendable (Kingfisher.KF.RedirectPayload) -> Swift.Void) -> Self
}
extension Kingfisher.KFOptionSetter {
  @_Concurrency.MainActor public func setProcessor(_ processor: any Kingfisher.ImageProcessor) -> Self
  @_Concurrency.MainActor public func setProcessors(_ processors: [any Kingfisher.ImageProcessor]) -> Self
  @_Concurrency.MainActor public func appendProcessor(_ processor: any Kingfisher.ImageProcessor) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func roundCorner(radius: Kingfisher.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: Kingfisher.RectCorner = .all, backgroundColor: Kingfisher.KFCrossPlatformColor? = nil) -> Self
  #endif
  @_Concurrency.MainActor public func blur(radius: CoreFoundation.CGFloat) -> Self
  @_Concurrency.MainActor public func overlay(color: Kingfisher.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5) -> Self
  @_Concurrency.MainActor public func tint(color: Kingfisher.KFCrossPlatformColor) -> Self
  @_Concurrency.MainActor public func blackWhite() -> Self
  @_Concurrency.MainActor public func cropping(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = .init(x: 0.5, y: 0.5)) -> Self
  @_Concurrency.MainActor public func downsampling(size: CoreFoundation.CGSize) -> Self
  @_Concurrency.MainActor public func resizing(referenceSize: CoreFoundation.CGSize, mode: Kingfisher.ContentMode = .none) -> Self
}
extension Kingfisher.KFOptionSetter {
  @_Concurrency.MainActor public func serialize(by cacheSerializer: any Kingfisher.CacheSerializer) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func serialize(as format: Kingfisher.ImageFormat, jpegCompressionQuality: CoreFoundation.CGFloat? = nil) -> Self
  #endif
}
extension Kingfisher.KFOptionSetter {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func imageModifier(_ modifier: (any Kingfisher.ImageModifier)?) -> Self
  #endif
  @_Concurrency.MainActor public func imageModifier(_ block: @escaping @Sendable (inout Kingfisher.KFCrossPlatformImage) throws -> Swift.Void) -> Self
}
extension Kingfisher.KFOptionSetter {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func memoryCacheExpiration(_ expiration: Kingfisher.StorageExpiration?) -> Self
  #endif
  @_Concurrency.MainActor public func memoryCacheAccessExtending(_ extending: Kingfisher.ExpirationExtending) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func diskCacheExpiration(_ expiration: Kingfisher.StorageExpiration?) -> Self
  #endif
  @_Concurrency.MainActor public func diskCacheAccessExtending(_ extending: Kingfisher.ExpirationExtending) -> Self
}
public enum KF {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func source(_ source: Kingfisher.Source?) -> Kingfisher.KF.Builder
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func resource(_ resource: (any Kingfisher.Resource)?) -> Kingfisher.KF.Builder
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> Kingfisher.KF.Builder
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func dataProvider(_ provider: (any Kingfisher.ImageDataProvider)?) -> Kingfisher.KF.Builder
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> Kingfisher.KF.Builder
  #endif
}
extension Kingfisher.KF {
  @_hasMissingDesignatedInitializers public class Builder : @unchecked Swift.Sendable {
    public var options: Kingfisher.KingfisherParsedOptionsInfo {
      get
      set
    }
    final public let onFailureDelegate: Kingfisher.Delegate<Kingfisher.KingfisherError, Swift.Void>
    final public let onSuccessDelegate: Kingfisher.Delegate<Kingfisher.RetrieveImageResult, Swift.Void>
    final public let onProgressDelegate: Kingfisher.Delegate<(Swift.Int64, Swift.Int64), Swift.Void>
    @objc deinit
  }
}
@_Concurrency.MainActor extension Kingfisher.KF.Builder {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func set(to imageView: Kingfisher.KFCrossPlatformImageView) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func set(to attachment: UIKit.NSTextAttachment, attributedView: @autoclosure @escaping @Sendable () -> Kingfisher.KFCrossPlatformView) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func set(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setBackground(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 14.0, *)
  @discardableResult
  @_Concurrency.MainActor public func set(to listItem: CarPlay.CPListItem) -> Kingfisher.DownloadTask?
  #endif
}
extension Kingfisher.KF.Builder {
  #if compiler(>=5.3) && $NonescapableTypes
  public func placeholder(_ placeholder: (any Kingfisher.Placeholder)?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func placeholder(_ image: Kingfisher.KFCrossPlatformImage?) -> Self
  #endif
}
extension Kingfisher.KF.Builder {
  public func transition(_ transition: Kingfisher.ImageTransition) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func keepCurrentImageWhileLoading(_ enabled: Swift.Bool = true) -> Self
  public func onlyLoadFirstFrame(_ enabled: Swift.Bool = true) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  public func progressiveJPEG(_ progressive: Kingfisher.ImageProgressive? = .init()) -> Self
  #endif
}
extension Kingfisher.KF.Builder {
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  public func loadImmediately(_ start: Swift.Bool = true) -> Self
}
extension Kingfisher.KF {
  public struct RedirectPayload {
    public let task: Kingfisher.SessionDataTask
    public let response: Foundation.HTTPURLResponse
    public let newRequest: Foundation.URLRequest
    public let completionHandler: (Foundation.URLRequest?) -> Swift.Void
  }
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct KingfisherWrapper<Base> : @unchecked Swift.Sendable {
  public let base: Base
  public init(_ base: Base)
}
public protocol KingfisherCompatible : AnyObject {
}
public protocol KingfisherCompatibleValue {
}
extension Kingfisher.KingfisherCompatible {
  public var kf: Kingfisher.KingfisherWrapper<Self> {
    get
    set
  }
}
extension Kingfisher.KingfisherCompatibleValue {
  public var kf: Kingfisher.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UIKit.UIImage : Kingfisher.KingfisherCompatible {
}
extension UIKit.UIImageView : Kingfisher.KingfisherCompatible {
}
extension UIKit.UIButton : Kingfisher.KingfisherCompatible {
}
extension UIKit.NSTextAttachment : Kingfisher.KingfisherCompatible {
}
extension PhotosUI.PHLivePhotoView : Kingfisher.KingfisherCompatible {
}
@available(iOS 14.0, *)
extension CarPlay.CPListItem : Kingfisher.KingfisherCompatible {
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public struct KFImage : Kingfisher.KFImageProtocol {
  @_Concurrency.MainActor public var context: Kingfisher.KFImage.Context<SwiftUICore.Image>
  @_Concurrency.MainActor public init(context: Kingfisher.KFImage.Context<SwiftUICore.Image>)
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s10Kingfisher15KFImageProtocolPAAE4bodyQrvp", 0) __<Kingfisher.KFImage>
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias HoldingView = SwiftUICore.Image
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.Image : Kingfisher.KFImageHoldingView {
  public typealias RenderingView = SwiftUICore.Image
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func created(from image: Kingfisher.KFCrossPlatformImage?, context: Kingfisher.KFImage.Context<SwiftUICore.Image>) -> SwiftUICore.Image
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImage {
  @_Concurrency.MainActor public func resizable(capInsets: SwiftUICore.EdgeInsets = EdgeInsets(), resizingMode: SwiftUICore.Image.ResizingMode = .stretch) -> Kingfisher.KFImage
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func renderingMode(_ renderingMode: SwiftUICore.Image.TemplateRenderingMode?) -> Kingfisher.KFImage
  #endif
  @_Concurrency.MainActor public func interpolation(_ interpolation: SwiftUICore.Image.Interpolation) -> Kingfisher.KFImage
  @_Concurrency.MainActor public func antialiased(_ isAntialiased: Swift.Bool) -> Kingfisher.KFImage
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  @_Concurrency.MainActor public func loadImmediately(_ start: Swift.Bool = true) -> Kingfisher.KFImage
}
public typealias ExecutionQueue = Kingfisher.CallbackQueue
public enum CallbackQueue : Swift.Sendable {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  public func execute(_ block: @escaping @Sendable () -> Swift.Void)
}
public struct FormatIndicatedCacheSerializer : Kingfisher.CacheSerializer {
  public static let png: Kingfisher.FormatIndicatedCacheSerializer
  public static let jpeg: Kingfisher.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreFoundation.CGFloat) -> Kingfisher.FormatIndicatedCacheSerializer
  public static let gif: Kingfisher.FormatIndicatedCacheSerializer
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(with image: Kingfisher.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func image(with data: Foundation.Data, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
extension CoreFoundation.CGSize : Kingfisher.KingfisherCompatibleValue {
}
extension Kingfisher.KingfisherWrapper where Base == CoreFoundation.CGSize {
  public func resize(to size: CoreFoundation.CGSize, for contentMode: Kingfisher.ContentMode) -> CoreFoundation.CGSize
  public func constrained(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func filling(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func constrainedRect(for size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint) -> CoreFoundation.CGRect
}
public typealias DownloadProgressBlock = (_ receivedSize: Swift.Int64, _ totalSize: Swift.Int64) -> Swift.Void
public struct RetrieveImageResult : Swift.Sendable {
  public let image: Kingfisher.KFCrossPlatformImage
  public let cacheType: Kingfisher.CacheType
  public let source: Kingfisher.Source
  public let originalSource: Kingfisher.Source
  public let data: @Sendable () -> Foundation.Data?
}
public struct PropagationError : Swift.Sendable {
  public let source: Kingfisher.Source
  public let error: Kingfisher.KingfisherError
}
public typealias DownloadTaskUpdatedBlock = @Sendable (_ newTask: Kingfisher.DownloadTask?) -> Swift.Void
public class KingfisherManager : @unchecked Swift.Sendable {
  public static let shared: Kingfisher.KingfisherManager
  public var cache: Kingfisher.ImageCache {
    get
    set
  }
  public var downloader: Kingfisher.ImageDownloader {
    get
    set
  }
  public var defaultOptions: Kingfisher.KingfisherOptionsInfo
  public init(downloader: Kingfisher.ImageDownloader, cache: Kingfisher.ImageCache)
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func retrieveImage(with resource: any Kingfisher.Resource, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, downloadTaskUpdated: Kingfisher.DownloadTaskUpdatedBlock? = nil, completionHandler: (@Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)?) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func retrieveImage(with source: Kingfisher.Source, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, downloadTaskUpdated: Kingfisher.DownloadTaskUpdatedBlock? = nil, completionHandler: (@Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)?) -> Kingfisher.DownloadTask?
  #endif
  @objc deinit
}
extension Kingfisher.KingfisherManager {
  #if compiler(>=5.3) && $NonescapableTypes
  public func retrieveImage(with resource: any Kingfisher.Resource, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil) async throws -> Kingfisher.RetrieveImageResult
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func retrieveImage(with source: Kingfisher.Source, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil) async throws -> Kingfisher.RetrieveImageResult
  #endif
}
public protocol AsyncImageDownloadRequestModifier : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  func modified(for request: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onDownloadTaskStarted: (@Sendable (Kingfisher.DownloadTask?) -> Swift.Void)? { get }
  #endif
}
public protocol ImageDownloadRequestModifier : Kingfisher.AsyncImageDownloadRequestModifier {
  #if compiler(>=5.3) && $NonescapableTypes
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  #endif
}
extension Kingfisher.ImageDownloadRequestModifier {
  #if compiler(>=5.3) && $NonescapableTypes
  public var onDownloadTaskStarted: (@Sendable (Kingfisher.DownloadTask?) -> Swift.Void)? {
    get
  }
  #endif
}
public struct AnyModifier : Kingfisher.ImageDownloadRequestModifier {
  #if compiler(>=5.3) && $NonescapableTypes
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(modify: @escaping @Sendable (Foundation.URLRequest) -> Foundation.URLRequest?)
  #endif
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity
  case image(imageData: Foundation.Data)
  case custom(indicator: any Kingfisher.Indicator)
}
@_Concurrency.MainActor public protocol Indicator : Swift.Sendable {
  @_Concurrency.MainActor func startAnimatingView()
  @_Concurrency.MainActor func stopAnimatingView()
  @_Concurrency.MainActor var centerOffset: CoreFoundation.CGPoint { get }
  @_Concurrency.MainActor var view: Kingfisher.IndicatorView { get }
  @_Concurrency.MainActor func sizeStrategy(in imageView: Kingfisher.KFCrossPlatformImageView) -> Kingfisher.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreFoundation.CGSize)
}
extension Kingfisher.Indicator {
  @_Concurrency.MainActor public var centerOffset: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor public func sizeStrategy(in imageView: Kingfisher.KFCrossPlatformImageView) -> Kingfisher.IndicatorSizeStrategy
}
public struct ImageLoadingResult : Swift.Sendable {
  public let image: Kingfisher.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
  #if compiler(>=5.3) && $NonescapableTypes
  public init(image: Kingfisher.KFCrossPlatformImage, url: Foundation.URL? = nil, originalData: Foundation.Data)
  #endif
}
@_hasMissingDesignatedInitializers final public class DownloadTask : @unchecked Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  final public var sessionTask: Kingfisher.SessionDataTask? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var cancelToken: Kingfisher.SessionDataTask.CancelToken? {
    get
  }
  #endif
  final public func cancel()
  final public var isInitialized: Swift.Bool {
    get
  }
  @objc deinit
}
open class ImageDownloader : @unchecked Swift.Sendable {
  public static let `default`: Kingfisher.ImageDownloader
  open var downloadTimeout: Foundation.TimeInterval {
    get
    set
  }
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var sessionDelegate: Kingfisher.SessionDelegate {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: (any Kingfisher.ImageDownloaderDelegate)?
  weak open var authenticationChallengeResponder: (any Kingfisher.AuthenticationChallengeResponsible)?
  public init(name: Swift.String)
  @objc deinit
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: Kingfisher.KingfisherParsedOptionsInfo, completionHandler: (@Sendable (Swift.Result<Kingfisher.ImageLoadingResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@Sendable (Swift.Result<Kingfisher.ImageLoadingResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@Sendable (Swift.Result<Kingfisher.ImageLoadingResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask
  #endif
}
extension Kingfisher.ImageDownloader {
  public func downloadImage(with url: Foundation.URL, options: Kingfisher.KingfisherParsedOptionsInfo) async throws -> Kingfisher.ImageLoadingResult
  #if compiler(>=5.3) && $NonescapableTypes
  public func downloadImage(with url: Foundation.URL, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil) async throws -> Kingfisher.ImageLoadingResult
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func downloadImage(with url: Foundation.URL, options: Kingfisher.KingfisherOptionsInfo? = nil) async throws -> Kingfisher.ImageLoadingResult
  #endif
}
extension Kingfisher.ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension Kingfisher.ImageDownloader : Kingfisher.AuthenticationChallengeResponsible {
}
extension Kingfisher.ImageDownloader : Kingfisher.ImageDownloaderDelegate {
}
@_hasMissingDesignatedInitializers public class RetryContext : @unchecked Swift.Sendable {
  final public let source: Kingfisher.Source
  final public let error: Kingfisher.KingfisherError
  public var retriedCount: Swift.Int {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var userInfo: Any? {
    get
  }
  #endif
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy : Swift.Sendable {
  func retry(context: Kingfisher.RetryContext, retryHandler: @escaping @Sendable (Kingfisher.RetryDecision) -> Swift.Void)
}
public struct DelayRetryStrategy : Kingfisher.RetryStrategy {
  public enum Interval : Swift.Sendable {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: @Sendable (_ retriedCount: Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: Kingfisher.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: Kingfisher.DelayRetryStrategy.Interval = .seconds(3))
  public func retry(context: Kingfisher.RetryContext, retryHandler: @escaping @Sendable (Kingfisher.RetryDecision) -> Swift.Void)
}
public enum ImageFormat : Swift.Sendable {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: Kingfisher.ImageFormat, b: Kingfisher.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : Kingfisher.KingfisherCompatibleValue {
}
extension Kingfisher.KingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: Kingfisher.ImageFormat {
    get
  }
  public func contains(jpeg marker: Kingfisher.ImageFormat.JPEGMarker) -> Swift.Bool
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, attributedView: @autoclosure @escaping @Sendable () -> Kingfisher.KFCrossPlatformView, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any Kingfisher.Resource)?, attributedView: @autoclosure @escaping @Sendable () -> Kingfisher.KFCrossPlatformView, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public var taskIdentifier: Kingfisher.Source.Identifier.Value? {
    get
  }
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImageProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func source(_ source: Kingfisher.Source?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func resource(_ resource: (any Kingfisher.Resource)?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func dataProvider(_ provider: (any Kingfisher.ImageDataProvider)?) -> Self
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> Self
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImageProtocol {
  @_Concurrency.MainActor public func placeholder<P>(@SwiftUICore.ViewBuilder _ content: @escaping (Foundation.Progress) -> P) -> Self where P : SwiftUICore.View
  @_Concurrency.MainActor public func placeholder<P>(@SwiftUICore.ViewBuilder _ content: @escaping () -> P) -> Self where P : SwiftUICore.View
  @_Concurrency.MainActor public func cancelOnDisappear(_ flag: Swift.Bool) -> Self
  @_Concurrency.MainActor public func reducePriorityOnDisappear(_ flag: Swift.Bool) -> Self
  @_Concurrency.MainActor public func fade(duration: Foundation.TimeInterval) -> Self
  @_Concurrency.MainActor public func startLoadingBeforeViewAppear(_ flag: Swift.Bool = true) -> Self
}
extension Foundation.NSNotification.Name {
  public static let KingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let KingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType : Swift.Sendable {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: Kingfisher.CacheType, b: Kingfisher.CacheType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CacheStoreResult : Swift.Sendable {
  public let memoryCacheResult: Swift.Result<(), Swift.Never>
  public let diskCacheResult: Swift.Result<(), Kingfisher.KingfisherError>
}
extension UIKit.UIImage : Kingfisher.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Foundation.Data : Kingfisher.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult : Swift.Sendable {
  case disk(Kingfisher.KFCrossPlatformImage)
  case memory(Kingfisher.KFCrossPlatformImage)
  case none
  #if compiler(>=5.3) && $NonescapableTypes
  public var image: Kingfisher.KFCrossPlatformImage? {
    get
  }
  #endif
  public var cacheType: Kingfisher.CacheType {
    get
  }
}
open class ImageCache : @unchecked Swift.Sendable {
  public static let `default`: Kingfisher.ImageCache
  final public let memoryStorage: Kingfisher.MemoryStorage.Backend<Kingfisher.KFCrossPlatformImage>
  final public let diskStorage: Kingfisher.DiskStorage.Backend<Foundation.Data>
  public typealias DiskCachePathClosure = @Sendable (Foundation.URL, Swift.String) -> Foundation.URL
  public init(memoryStorage: Kingfisher.MemoryStorage.Backend<Kingfisher.KFCrossPlatformImage>, diskStorage: Kingfisher.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: Kingfisher.ImageCache.DiskCachePathClosure? = nil) throws
  #endif
  @objc deinit
  #if compiler(>=5.3) && $NonescapableTypes
  open func store(_ image: Kingfisher.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: Kingfisher.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: (@Sendable (Kingfisher.CacheStoreResult) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func store(_ image: Kingfisher.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, cacheSerializer serializer: any Kingfisher.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: Kingfisher.CallbackQueue = .untouch, completionHandler: (@Sendable (Kingfisher.CacheStoreResult) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, expiration: Kingfisher.StorageExpiration? = nil, callbackQueue: Kingfisher.CallbackQueue = .untouch, completionHandler: (@Sendable (Kingfisher.CacheStoreResult) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: Kingfisher.CallbackQueue = .untouch, completionHandler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func retrieveImage(forKey key: Swift.String, options: Kingfisher.KingfisherParsedOptionsInfo, callbackQueue: Kingfisher.CallbackQueue = .mainCurrentOrAsync, completionHandler: (@Sendable (Swift.Result<Kingfisher.ImageCacheResult, Kingfisher.KingfisherError>) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func retrieveImage(forKey key: Swift.String, options: Kingfisher.KingfisherOptionsInfo? = nil, callbackQueue: Kingfisher.CallbackQueue = .mainCurrentOrAsync, completionHandler: (@Sendable (Swift.Result<Kingfisher.ImageCacheResult, Kingfisher.KingfisherError>) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: Kingfisher.KingfisherOptionsInfo? = nil) -> Kingfisher.KFCrossPlatformImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: Kingfisher.KingfisherOptionsInfo? = nil, callbackQueue: Kingfisher.CallbackQueue = .untouch, completionHandler: @escaping @Sendable (Swift.Result<Kingfisher.KFCrossPlatformImage?, Kingfisher.KingfisherError>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func clearCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  @objc public func clearMemoryCache()
  #if compiler(>=5.3) && $NonescapableTypes
  open func clearDiskCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func cleanExpiredCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  open func cleanExpiredMemoryCache()
  #if compiler(>=5.3) && $NonescapableTypes
  open func cleanExpiredDiskCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  @_Concurrency.MainActor @objc public func backgroundCleanExpiredDiskCache()
  #if compiler(>=5.3) && $NonescapableTypes
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Kingfisher.CacheType
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Swift.String
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func calculateDiskStorageSize(completion handler: @escaping @Sendable (Swift.Result<Swift.UInt, Kingfisher.KingfisherError>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Swift.String
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func cacheFileURLIfOnDisk(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Foundation.URL?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func store(_ image: Kingfisher.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: Kingfisher.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func store(_ image: Kingfisher.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, cacheSerializer serializer: any Kingfisher.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, expiration: Kingfisher.StorageExpiration? = nil) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true) async throws
  #endif
  open func retrieveImage(forKey key: Swift.String, options: Kingfisher.KingfisherParsedOptionsInfo) async throws -> Kingfisher.ImageCacheResult
  #if compiler(>=5.3) && $NonescapableTypes
  open func retrieveImage(forKey key: Swift.String, options: Kingfisher.KingfisherOptionsInfo? = nil) async throws -> Kingfisher.ImageCacheResult
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: Kingfisher.KingfisherOptionsInfo? = nil) async throws -> Kingfisher.KFCrossPlatformImage?
  #endif
  open func clearCache() async
  open func clearDiskCache() async
  open func cleanExpiredCache() async
  open func cleanExpiredDiskCache() async
  open var diskStorageSize: Swift.UInt {
    get async throws
  }
}
extension UIKit.UIApplication : Kingfisher.KingfisherCompatible {
}
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIApplication {
  #if compiler(>=5.3) && $NonescapableTypes
  public static var shared: UIKit.UIApplication? {
    get
  }
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public protocol KFImageProtocol : Kingfisher.KFOptionSetter, SwiftUICore.View {
  associatedtype HoldingView : Kingfisher.KFImageHoldingView
  @_Concurrency.MainActor var context: Kingfisher.KFImage.Context<Self.HoldingView> { get set }
  @_Concurrency.MainActor init(context: Kingfisher.KFImage.Context<Self.HoldingView>)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImageProtocol {
  @_Concurrency.MainActor public var body: some SwiftUICore.View {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public init(source: Kingfisher.Source?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public init(_ url: Foundation.URL?)
  #endif
  @_Concurrency.MainActor public func configure(_ block: @escaping (Self.HoldingView) -> Self.HoldingView) -> Self
  @_Concurrency.MainActor public func contentConfigure<V>(_ block: @escaping (Self.HoldingView) -> V) -> Self where V : SwiftUICore.View
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public protocol KFImageHoldingView : SwiftUICore.View {
  associatedtype RenderingView
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor static func created(from image: Kingfisher.KFCrossPlatformImage?, context: Kingfisher.KFImage.Context<Self>) -> Self
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImageProtocol {
  @_Concurrency.MainActor public var options: Kingfisher.KingfisherParsedOptionsInfo {
    get
    nonmutating set
  }
  @_Concurrency.MainActor public var onFailureDelegate: Kingfisher.Delegate<Kingfisher.KingfisherError, Swift.Void> {
    get
  }
  @_Concurrency.MainActor public var onSuccessDelegate: Kingfisher.Delegate<Kingfisher.RetrieveImageResult, Swift.Void> {
    get
  }
  @_Concurrency.MainActor public var onProgressDelegate: Kingfisher.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> {
    get
  }
  @_Concurrency.MainActor public var delegateObserver: Swift.AnyObject {
    get
  }
}
public typealias PrefetcherProgressBlock = (_ skippedResources: [any Kingfisher.Resource], _ failedResources: [any Kingfisher.Resource], _ completedResources: [any Kingfisher.Resource]) -> Swift.Void
public typealias PrefetcherSourceProgressBlock = (_ skippedSources: [Kingfisher.Source], _ failedSources: [Kingfisher.Source], _ completedSources: [Kingfisher.Source]) -> Swift.Void
public typealias PrefetcherCompletionHandler = (_ skippedResources: [any Kingfisher.Resource], _ failedResources: [any Kingfisher.Resource], _ completedResources: [any Kingfisher.Resource]) -> Swift.Void
public typealias PrefetcherSourceCompletionHandler = (_ skippedSources: [Kingfisher.Source], _ failedSources: [Kingfisher.Source], _ completedSources: [Kingfisher.Source]) -> Swift.Void
@_hasMissingDesignatedInitializers public class ImagePrefetcher : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(urls: [Foundation.URL], options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.PrefetcherProgressBlock? = nil, completionHandler: Kingfisher.PrefetcherCompletionHandler? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(resources: [any Kingfisher.Resource], options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.PrefetcherProgressBlock? = nil, completionHandler: Kingfisher.PrefetcherCompletionHandler? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(sources: [Kingfisher.Source], options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.PrefetcherSourceProgressBlock? = nil, completionHandler: Kingfisher.PrefetcherSourceCompletionHandler? = nil)
  #endif
  public func start()
  public func stop()
  @objc deinit
}
@available(iOS 14.0, macOS 13.0, *)
extension PhotosUI.PHPickerResult : @unchecked @retroactive Swift.Sendable {
}
@available(iOS 14.0, macOS 13.0, *)
public struct PHPickerResultImageDataProvider : Kingfisher.ImageDataProvider {
  public enum PHPickerResultImageDataProviderError : Swift.Error {
    case pickerProviderError(any Swift.Error)
    case invalidImage
  }
  public let pickerResult: PhotosUI.PHPickerResult
  public let contentType: UniformTypeIdentifiers.UTType
  public var cacheKey: Swift.String {
    get
  }
  public init(pickerResult: PhotosUI.PHPickerResult, contentType: UniformTypeIdentifiers.UTType = UTType.image)
  #if compiler(>=5.3) && $NonescapableTypes
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
}
extension QuartzCore.CADisplayLink : @unchecked @retroactive Swift.Sendable {
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImageView {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, placeholder: (any Kingfisher.Placeholder)? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, placeholder: (any Kingfisher.Placeholder)? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any Kingfisher.Resource)?, placeholder: (any Kingfisher.Placeholder)? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any Kingfisher.Resource)?, placeholder: (any Kingfisher.Placeholder)? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any Kingfisher.ImageDataProvider)?, placeholder: (any Kingfisher.Placeholder)? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any Kingfisher.ImageDataProvider)?, placeholder: (any Kingfisher.Placeholder)? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImageView {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public var taskIdentifier: Kingfisher.Source.Identifier.Value? {
    get
  }
  #endif
  @_Concurrency.MainActor public var indicatorType: Kingfisher.IndicatorType {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public var indicator: (any Kingfisher.Indicator)? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public var placeholder: (any Kingfisher.Placeholder)? {
    get
  }
  #endif
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : UIKit.UIButton {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any Kingfisher.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, parsedOptions: Kingfisher.KingfisherParsedOptionsInfo, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelImageDownloadTask()
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setBackgroundImage(with source: Kingfisher.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setBackgroundImage(with resource: (any Kingfisher.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelBackgroundImageDownloadTask()
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : UIKit.UIButton {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func taskIdentifier(for state: UIKit.UIControl.State) -> Kingfisher.Source.Identifier.Value?
  #endif
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : UIKit.UIButton {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> Kingfisher.Source.Identifier.Value?
  #endif
}
public struct LivePhotoResourceDownloadingResult : Swift.Sendable {
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
  #if compiler(>=5.3) && $NonescapableTypes
  public init(originalData: Foundation.Data, url: Foundation.URL? = nil)
  #endif
}
extension Kingfisher.ImageDownloader {
  public func downloadLivePhotoResource(with url: Foundation.URL, options: Kingfisher.KingfisherParsedOptionsInfo) async throws -> Kingfisher.LivePhotoResourceDownloadingResult
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func downloadLivePhotoResource(with url: Foundation.URL, options: Kingfisher.KingfisherParsedOptionsInfo, completionHandler: (@Sendable (Swift.Result<Kingfisher.LivePhotoResourceDownloadingResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask
  #endif
}
public struct ImageCreatingOptions {
  public var scale: CoreFoundation.CGFloat
  public var duration: Foundation.TimeInterval
  public var preloadAll: Swift.Bool
  public var onlyFirstFrame: Swift.Bool
  public init(scale: CoreFoundation.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers public class GIFAnimatedImage {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func getFrameDuration(from gifInfo: [Swift.String : Any]?) -> Foundation.TimeInterval
  #endif
  public static func getFrameDuration(from imageSource: ImageIO.CGImageSource, at index: Swift.Int) -> Foundation.TimeInterval
  @objc deinit
}
public protocol ImageFrameSource {
  #if compiler(>=5.3) && $NonescapableTypes
  var data: Foundation.Data? { get }
  #endif
  var frameCount: Swift.Int { get }
  #if compiler(>=5.3) && $NonescapableTypes
  func frame(at index: Swift.Int, maxSize: CoreFoundation.CGSize?) -> CoreGraphics.CGImage?
  #endif
  func duration(at index: Swift.Int) -> Foundation.TimeInterval
}
extension Kingfisher.ImageFrameSource {
  #if compiler(>=5.3) && $NonescapableTypes
  public func frame(at index: Swift.Int) -> CoreGraphics.CGImage?
  #endif
}
@available(iOS 14.0, *)
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : CarPlay.CPListItem {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.Source?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any Kingfisher.Resource)?, placeholder: Kingfisher.KFCrossPlatformImage? = nil, options: Kingfisher.KingfisherOptionsInfo? = nil, progressBlock: Kingfisher.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveImageResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> Kingfisher.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : CarPlay.CPListItem {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public var taskIdentifier: Kingfisher.Source.Identifier.Value? {
    get
  }
  #endif
}
public enum Source : Swift.Sendable {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(any Kingfisher.Resource)
  case provider(any Kingfisher.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var url: Foundation.URL? {
    get
  }
  #endif
}
extension Kingfisher.Source : Swift.Hashable {
  public static func == (lhs: Kingfisher.Source, rhs: Kingfisher.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject, @unchecked Swift.Sendable {
  @objc override dynamic public init()
  @objc deinit
}
extension Kingfisher.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
}
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : Kingfisher.ImageProcessor {
  var filter: Kingfisher.Filter { get }
}
extension Kingfisher.CIImageProcessor {
  #if compiler(>=5.3) && $NonescapableTypes
  public func process(item: Kingfisher.ImageProcessItem, options: Kingfisher.KingfisherParsedOptionsInfo) -> Kingfisher.KFCrossPlatformImage?
  #endif
}
public struct Filter {
  public init(transform: @escaping Kingfisher.Transformer)
  public static let tint: @Sendable (_ color: Kingfisher.KFCrossPlatformColor) -> Kingfisher.Filter
  public struct ColorElement {
    public let brightness: CoreFoundation.CGFloat
    public let contrast: CoreFoundation.CGFloat
    public let saturation: CoreFoundation.CGFloat
    public let inputEV: CoreFoundation.CGFloat
    public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  }
  public static let colorControl: @Sendable (_ arg: Kingfisher.Filter.ColorElement) -> Kingfisher.Filter
}
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public func apply(_ filter: Kingfisher.Filter) -> Kingfisher.KFCrossPlatformImage
}
public protocol Resource : Swift.Sendable {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension Kingfisher.Resource {
  #if compiler(>=5.3) && $NonescapableTypes
  public func convertToSource(overrideCacheKey: Swift.String? = nil) -> Kingfisher.Source
  #endif
}
@available(*, deprecated, renamed: "KF.ImageResource", message: "This type conflicts with `GeneratedAssetSymbols.ImageResource` in Swift 5.9. Renamed to avoid issues in the future.")
public typealias ImageResource = Kingfisher.KF.ImageResource
extension Kingfisher.KF {
  public struct ImageResource : Kingfisher.Resource {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
    #endif
    public let cacheKey: Swift.String
    public let downloadURL: Foundation.URL
  }
}
extension Foundation.URL : Kingfisher.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
public protocol ImageDownloadRedirectHandler : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  func handleHTTPRedirection(for task: Kingfisher.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
}
public struct AnyRedirectHandler : Kingfisher.ImageDownloadRedirectHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  public func handleHTTPRedirection(for task: Kingfisher.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(handle: @escaping @Sendable (Kingfisher.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public struct KFAnimatedImage : Kingfisher.KFImageProtocol {
  public typealias HoldingView = Kingfisher.KFAnimatedImageViewRepresenter
  @_Concurrency.MainActor public var context: Kingfisher.KFImage.Context<Kingfisher.KFAnimatedImage.HoldingView>
  @_Concurrency.MainActor public init(context: Kingfisher.KFImage.Context<Kingfisher.KFAnimatedImage.HoldingView>)
  @_Concurrency.MainActor public func configure(_ block: @escaping (Kingfisher.KFAnimatedImage.HoldingView.RenderingView) -> Swift.Void) -> Kingfisher.KFAnimatedImage
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s10Kingfisher15KFImageProtocolPAAE4bodyQrvp", 0) __<Kingfisher.KFAnimatedImage>
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor @preconcurrency public struct KFAnimatedImageViewRepresenter : Kingfisher.KFImageHoldingView {
  public typealias RenderingView = Kingfisher.AnimatedImageView
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func created(from image: Kingfisher.KFCrossPlatformImage?, context: Kingfisher.KFImage.Context<Kingfisher.KFAnimatedImageViewRepresenter>) -> Kingfisher.KFAnimatedImageViewRepresenter
  #endif
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: Kingfisher.KFAnimatedImageViewRepresenter.Context) -> Kingfisher.AnimatedImageView
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ uiView: Kingfisher.AnimatedImageView, context: Kingfisher.KFAnimatedImageViewRepresenter.Context)
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias Body = Swift.Never
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias Coordinator = Swift.Void
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias UIViewType = Kingfisher.AnimatedImageView
}
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  #if compiler(>=5.3) && $NonescapableTypes
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: Kingfisher.KFCrossPlatformColor? = nil) -> Kingfisher.KFCrossPlatformImage
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func image(withRadius radius: Kingfisher.Radius, fit size: CoreFoundation.CGSize, roundingCorners corners: Kingfisher.RectCorner = .all, backgroundColor: Kingfisher.KFCrossPlatformColor? = nil) -> Kingfisher.KFCrossPlatformImage
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func image(withRoundRadius radius: CoreFoundation.CGFloat, fit size: CoreFoundation.CGSize, roundingCorners corners: Kingfisher.RectCorner = .all, backgroundColor: Kingfisher.KFCrossPlatformColor? = nil) -> Kingfisher.KFCrossPlatformImage
  #endif
  public func resize(to size: CoreFoundation.CGSize) -> Kingfisher.KFCrossPlatformImage
  public func resize(to targetSize: CoreFoundation.CGSize, for contentMode: Kingfisher.ContentMode) -> Kingfisher.KFCrossPlatformImage
  public func crop(to size: CoreFoundation.CGSize, anchorOn anchor: CoreFoundation.CGPoint) -> Kingfisher.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreFoundation.CGFloat) -> Kingfisher.KFCrossPlatformImage
  public func addingBorder(_ border: Kingfisher.Border) -> Kingfisher.KFCrossPlatformImage
  public func overlaying(with color: Kingfisher.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat) -> Kingfisher.KFCrossPlatformImage
  public func tinted(with color: Kingfisher.KFCrossPlatformColor) -> Kingfisher.KFCrossPlatformImage
  public func adjusted(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat) -> Kingfisher.KFCrossPlatformImage
  public func scaled(to scale: CoreFoundation.CGFloat) -> Kingfisher.KFCrossPlatformImage
}
extension Kingfisher.KingfisherWrapper where Base : UIKit.UIImage {
  public var decoded: Kingfisher.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreFoundation.CGFloat) -> Kingfisher.KFCrossPlatformImage
  public func decoded(on context: CoreGraphics.CGContext) -> Kingfisher.KFCrossPlatformImage
}
@_hasMissingDesignatedInitializers public class SessionDataTask : @unchecked Swift.Sendable {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
  }
  final public let originalURL: Foundation.URL?
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
public enum KingfisherError : Swift.Error {
  public enum RequestErrorReason : Swift.Sendable {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: Kingfisher.SessionDataTask, token: Kingfisher.SessionDataTask.CancelToken)
    case livePhotoTaskCancelled(source: Kingfisher.LivePhotoSource)
  }
  public enum ResponseErrorReason : Swift.Sendable {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: any Swift.Error)
    case dataModifyingFailed(task: Kingfisher.SessionDataTask)
    case noURLResponse(task: Kingfisher.SessionDataTask)
    case cancelledByDelegate(response: Foundation.URLResponse)
  }
  public enum CacheErrorReason : @unchecked Swift.Sendable {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: any Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: any Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: any Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: any Swift.Error)
    case cannotSerializeImage(image: Kingfisher.KFCrossPlatformImage?, original: Foundation.Data?, serializer: any Kingfisher.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: any Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: any Swift.Error)
    case diskStorageIsNotReady(cacheURL: Foundation.URL)
    case missingLivePhotoResourceOnDisk(_: Kingfisher.LivePhotoResource)
  }
  public enum ProcessorErrorReason : Swift.Sendable {
    case processingFailed(processor: any Kingfisher.ImageProcessor, item: Kingfisher.ImageProcessItem)
  }
  public enum ImageSettingErrorReason : Swift.Sendable {
    case emptySource
    case notCurrentSourceTask(result: Kingfisher.RetrieveImageResult?, error: (any Swift.Error)?, source: Kingfisher.Source)
    case dataProviderError(provider: any Kingfisher.ImageDataProvider, error: any Swift.Error)
    case alternativeSourcesExhausted([Kingfisher.PropagationError])
    case notCurrentLivePhotoSourceTask(result: Kingfisher.RetrieveLivePhotoResult?, error: (any Swift.Error)?, source: Kingfisher.LivePhotoSource)
    case livePhotoResultError(result: Kingfisher.RetrieveLivePhotoResult?, error: (any Swift.Error)?, source: Kingfisher.LivePhotoSource)
  }
  case requestError(reason: Kingfisher.KingfisherError.RequestErrorReason)
  case responseError(reason: Kingfisher.KingfisherError.ResponseErrorReason)
  case cacheError(reason: Kingfisher.KingfisherError.CacheErrorReason)
  case processorError(reason: Kingfisher.KingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: Kingfisher.KingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension Kingfisher.KingfisherError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension Kingfisher.KingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
@available(*, deprecated, renamed: "AuthenticationChallengeResponsible", message: "Typo. Use `AuthenticationChallengeResponsible` instead")
public typealias AuthenticationChallengeResponsable = Kingfisher.AuthenticationChallengeResponsible
public protocol AuthenticationChallengeResponsible : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  func downloader(_ downloader: Kingfisher.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func downloader(_ downloader: Kingfisher.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
}
extension Kingfisher.AuthenticationChallengeResponsible {
  #if compiler(>=5.3) && $NonescapableTypes
  public func downloader(_ downloader: Kingfisher.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func downloader(_ downloader: Kingfisher.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
}
extension Swift.String : Kingfisher.KingfisherCompatibleValue {
}
public struct RetrieveLivePhotoResult : @unchecked Swift.Sendable {
  public let loadingInfo: Kingfisher.LivePhotoLoadingInfoResult
  public let livePhoto: Photos.PHLivePhoto?
  public let info: [Swift.AnyHashable : Any]?
}
@_Concurrency.MainActor extension Kingfisher.KingfisherWrapper where Base : PhotosUI.PHLivePhotoView {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public var taskIdentifier: Kingfisher.Source.Identifier.Value? {
    get
  }
  #endif
  @_Concurrency.MainActor public var targetSize: CoreFoundation.CGSize {
    get
    set
  }
  @_Concurrency.MainActor public var contentMode: Photos.PHImageContentMode {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with urls: [Foundation.URL], options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveLivePhotoResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> _Concurrency.Task<(), Swift.Never>?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: Kingfisher.LivePhotoSource?, options: Kingfisher.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Kingfisher.RetrieveLivePhotoResult, Kingfisher.KingfisherError>) -> Swift.Void)? = nil) -> _Concurrency.Task<(), Swift.Never>?
  #endif
}
public typealias KingfisherOptionsInfo = [Kingfisher.KingfisherOptionsInfoItem]
public enum KingfisherOptionsInfoItem : Swift.Sendable {
  case targetCache(Kingfisher.ImageCache)
  case originalCache(Kingfisher.ImageCache)
  case downloader(Kingfisher.ImageDownloader)
  case transition(Kingfisher.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  case callbackQueue(Kingfisher.CallbackQueue)
  case scaleFactor(CoreFoundation.CGFloat)
  case preloadAllAnimationData
  case requestModifier(any Kingfisher.AsyncImageDownloadRequestModifier)
  case redirectHandler(any Kingfisher.ImageDownloadRedirectHandler)
  case processor(any Kingfisher.ImageProcessor)
  case cacheSerializer(any Kingfisher.CacheSerializer)
  case imageModifier(any Kingfisher.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(Kingfisher.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case diskStoreWriteOptions(Foundation.Data.WritingOptions)
  case memoryCacheExpiration(Kingfisher.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(Kingfisher.ExpirationExtending)
  case diskCacheExpiration(Kingfisher.StorageExpiration)
  case diskCacheAccessExtendingExpiration(Kingfisher.ExpirationExtending)
  case processingQueue(Kingfisher.CallbackQueue)
  case progressiveJPEG(Kingfisher.ImageProgressive)
  case alternativeSources([Kingfisher.Source])
  case retryStrategy(any Kingfisher.RetryStrategy)
  case lowDataMode(Kingfisher.Source?)
  case forcedCacheFileExtension(Swift.String?)
}
public struct KingfisherParsedOptionsInfo : Swift.Sendable {
  public var targetCache: Kingfisher.ImageCache?
  public var originalCache: Kingfisher.ImageCache?
  public var downloader: Kingfisher.ImageDownloader?
  public var transition: Kingfisher.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: Kingfisher.CallbackQueue
  public var scaleFactor: CoreFoundation.CGFloat
  public var requestModifier: (any Kingfisher.AsyncImageDownloadRequestModifier)?
  public var redirectHandler: (any Kingfisher.ImageDownloadRedirectHandler)?
  public var processor: any Kingfisher.ImageProcessor
  public var imageModifier: (any Kingfisher.ImageModifier)?
  public var cacheSerializer: any Kingfisher.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: Kingfisher.KFCrossPlatformImage??
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var diskStoreWriteOptions: Foundation.Data.WritingOptions
  public var memoryCacheExpiration: Kingfisher.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: Kingfisher.ExpirationExtending
  public var diskCacheExpiration: Kingfisher.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: Kingfisher.ExpirationExtending
  public var processingQueue: Kingfisher.CallbackQueue?
  public var progressiveJPEG: Kingfisher.ImageProgressive?
  public var alternativeSources: [Kingfisher.Source]?
  public var retryStrategy: (any Kingfisher.RetryStrategy)?
  public var lowDataModeSource: Kingfisher.Source?
  public var forcedExtension: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(_ info: Kingfisher.KingfisherOptionsInfo?)
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFImage : Swift.Sendable {}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFAnimatedImage : Swift.Sendable {}
extension Kingfisher.ContentMode : Swift.Equatable {}
extension Kingfisher.ContentMode : Swift.Hashable {}
extension Kingfisher.ImageFormat : Swift.Equatable {}
extension Kingfisher.ImageFormat : Swift.Hashable {}
extension Kingfisher.CacheType : Swift.Equatable {}
extension Kingfisher.CacheType : Swift.Hashable {}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFAnimatedImageViewRepresenter : SwiftUI.UIViewRepresentable {}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Kingfisher.KFAnimatedImageViewRepresenter : Swift.Sendable {}
